; colons are optional (whitespace)

(module Foo exposing (bar baz))
(module Bar exposing (baz, foo))
(module Nested.Bar exposing (..))
(module Baz exposing ((Msg (..))))
(module Nasty exposing ((Msg (..)), Model))

(port-module Foo exposing (myPort))

(import Html)
(import Random exposing (..))
(import Set exposing ((Msg (..))))
(import Json.Decode as JD)
(import Json.Encode as JE exposing (value string))

(type-alias Model Int)
(type-alias User {name String, age Int}) ; TODO records
(type-alias MyHtml (Html Int))
(type-alias MyCmd (Cmd (List String)))
(type-alias (Param a) (Html (List a)))

(type Bool
  True
  False)

(type (Maybe a)
  Nothing
  (Just a))
  
(type Msg
  NoOp
  Increment
  (DecrementBy Int)
  (SetName String))

(input-port sendString String)
(input-port sendList (List String))

(output-port listenBool Bool)
(output-port listenList (List String))

|this is copied verbatim,
if you ever need it!

and look, it's multiline!|

(lambda x (+ x 1)) ; TODO binary ops
(lambda (x y) (+ x y)) ; TODO binary ops

(def val 1)
(def myNum : Int
  2)

(if True
  "a"
  "b")

(case msg
  (Increment 1)
  ((DecrementBy amount) (- amount)))

; TODO (effect-module) ; otherwise the same as (module) ?? read up on it :)

; TODO {name String, age Int} => (elm-record name String age Int) ; => { name : String, age : Int }
; TODO {name "a", age 1}      => (elm-record name "a" age 1)      ; => { name = "a", age = 1 }
; will have to format elm-record differently in types and in values!

; TODO [1 2 3]  => (elm-list 1 2 3)  => [1, 2, 3]
; TODO #[1 "a"] => (elm-tuple 1 "a") => (1, "a")

; TODO SPECIFY TODOS :)
; --------------------------
; TODO (defn
; TODO (defn : type
; TODO (let
; TODO (case
; TODO binary ops

; TODO macro for specifying things as binary ops

; TODO argument destructuring?
; TODO arg destructuring - ADTs with only one constructor?

; TODO try creating a "where" alternative for "let" ?

; TODO how will #t #f vs True False play out for macros?

; TODO operators both unary and binary? (-)
